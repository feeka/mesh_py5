<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Twin Keys – Final Static Version</title>
  <style> body { margin:0; overflow:hidden; background:#000; } </style>
</head>
<body>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js';

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 0, 65);
camera.lookAt(0, 0, 0);               // camera locked forever

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

// Grid
const cols = 200, rows = 120;
const spacing = 1.25;
const radius = 0.48;

const group = new THREE.Group();
group.rotation.x = -Math.PI/2;
group.position.set(0,0,0);            // wall completely locked
scene.add(group);

const geo = new THREE.CylinderGeometry(radius, radius, 0.55, 48);
geo.rotateX(Math.PI/2);

const mat = new THREE.MeshStandardMaterial({
  color:0xffffff, metalness:0.99, roughness:0.04,
  emissive:0x001122, emissiveIntensity:0
});

const keys = [];
for(let r=0;r<rows;r++){
  for(let c=0;c<cols;c++){
    const x = (c-cols/2)*spacing;
    const z = (r-rows/2)*spacing;

    const front = new THREE.Mesh(geo, mat);
    front.position.set(x,0,z);
    group.add(front);

    const back = new THREE.Mesh(geo, mat);
    back.rotation.y = Math.PI;
    back.position.set(x,0,z);
    group.add(back);

    const state = {y:0, v:0, target:0, k:200, d:14};
    front.userData = state;
    back.userData = state;

    keys.push({front, back});
  }
}

// Fixed lighting
scene.add(new THREE.AmbientLight(0x222233,1.4));
const light = new THREE.DirectionalLight(0xccddff,3);
light.position.set(0,30,55);
scene.add(light);

let t=0;
function animate(){
  requestAnimationFrame(animate);
  t += 0.016;

  // Ghost typists (same as before)
  for(let i=0;i<7;i++){
    const tx = Math.sin(t*0.55+i*1.1)*34;
    const tz = Math.cos(t*0.44+i*1.3)*52;
    const pulse = Math.max(0, Math.sin(t*15+i*66));

    keys.forEach(pair=>{
      const d = Math.hypot(pair.front.position.x-tx, pair.front.position.z-tz);
      if(d<14){
        pair.front.userData.target = -2.6*Math.exp(-d*0.15)*pulse;
      } else {
        pair.front.userData.target *= 0.96;
      }
    });
  }

  // Physics (unchanged — beautiful)
  keys.forEach(pair=>{
    const s = pair.front.userData;
    const f = -s.k*(s.y-s.target);
    const damp = -s.d*s.v;
    s.v += (f+damp)*0.016;
    s.v *= 0.985;
    s.y += s.v*0.016;

    pair.front.position.y = s.y;
    pair.back.position.y  = -s.y;

    const glow = Math.max(0, Math.abs(s.v)*3 + Math.abs(s.y)*0.8);
    pair.front.material.emissiveIntensity = glow*0.08;
    pair.back.material.emissiveIntensity  = glow*0.08;

    const warp = Math.sin(t*0.6 + pair.front.position.z*0.04)*0.04;
    const scale = 1 + warp + Math.abs(s.y)*0.25;
    pair.front.scale.y = scale;
    pair.back.scale.y  = scale;
  });

  renderer.render(scene,camera);   // nothing else moves
}

window.addEventListener('resize',()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

animate();
</script>
</body>
</html>